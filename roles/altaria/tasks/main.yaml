---
- name: Update apt's package index
  ansible.builtin.apt:
    update_cache: yes
  become: yes

- name: Create altaria's data directory
  ansible.builtin.file:
    path: "{{ _altaria_data_dir }}"
    state: directory
    mode: "700"
  become: yes
  register: creating_altaria_source_dir_check
  changed_when: creating_altaria_source_dir_check.state == "absent"

# This list is specific to Ubuntu/Debian at the moment. Can be expanded to a vars
# directory to install dependencies based on the distro.
- name: Install pyenv dependencies
  ansible.builtin.apt:
    name:
      - build-essential
      - curl
      - git
      - libbz2-dev
      - libffi-dev
      - liblzma-dev
      - libncurses5-dev
      - libncursesw5-dev
      - libreadline-dev
      - libsqlite3-dev
      - libssl-dev
      - llvm
      - make
      - python3-openssl
      - tk-dev
      - wget
      - xz-utils
      - zlib1g-dev
    state: present
  become: yes

- name: Install system dependencies
  ansible.builtin.apt:
    name:
      - gettext-base # for envsubst
      - jq
      - openjdk-11-jre-headless
    state: present
  become: yes

# Assumes /usr/local/bin comes before /usr/bin in the shell's default PATH (e.g.
# the one "hardcoded" into the shell binary).
- name: Create system make wrapper
  ansible.builtin.copy:
    dest: /usr/local/bin/make
    mode: "755"
    content: |
      #!/bin/sh
      #
      # ANSIBLE MANAGED

      export GPS_CONFIG_FILE_PATH="{{ gps_config_file_path }}"
      export PYENV_ROOT="{{ _jenkins_pyenv_root_path }}"
      PATH="${PYENV_ROOT}/plugins/pyenv-virtualenv/shims:${PYENV_ROOT}/shims:${PYENV_ROOT}/bin:${PATH}"
      export PATH

      /usr/bin/make "$@"

- name: Create root's .profile
  ansible.builtin.copy:
    dest: "{{ _roots_home }}/.profile"
    mode: "644"
    force: yes
    content: |
      #
      #
      # ANSIBLE MANAGED

      export PYENV_ROOT="{{ _jenkins_pyenv_root_path }}"
      export PATH="${PYENV_ROOT}/bin:${PATH}"
      eval "$(pyenv init --path)"

- name: Create root's .bashrc
  ansible.builtin.copy:
    dest: "{{ _roots_home }}/.bashrc"
    mode: "644"
    force: yes
    content: |
      #
      #
      # ANSIBLE MANAGED

      # not anticipating to login as root, so .profile must be read first
      [ -r "${HOME}/.profile" ] && . "${HOME}/.profile"

      eval "$(pyenv init -)"
      eval "$(pyenv virtualenv-init -)"

- name: Create jenkins user
  ansible.builtin.user:
    name: "{{ jenkins_user }}"
    state: present
    home: /home/{{ jenkins_user }}
    shell: /bin/bash
    password: "{{ jenkins_user_password }}"
  become: yes

- name: Create {{ jenkins_user }}'s .profile
  ansible.builtin.copy:
    dest: "{{ _jenkins_user_home }}/.profile"
    mode: "644"
    force: yes
    content: |
      #
      #
      # ANSIBLE MANAGED

      export PYENV_ROOT="{{ _jenkins_pyenv_root_path }}"
      export PATH="${PYENV_ROOT}/bin:${PATH}"
      eval "$(pyenv init --path)"

      # if running bash
      if [ -n "${BASH_VERSION}" ]; then
          if [ -f "${HOME}/.bashrc" ]; then
              . "${HOME}/.bashrc"
          fi
      fi

- name: Append pyenv setup to {{ jenkins_user }}'s .bashrc
  ansible.builtin.import_role:
    name: cavcrosby.general.common
    tasks_from: managed_blockinfile
  vars:
    path: "{{ _jenkins_user_home }}/.bashrc"
    block_identifier: "pyenv setup"
    block_text: |
      eval "$(pyenv init -)"
      eval "$(pyenv virtualenv-init -)"

- name: Create {{ jenkins_user }}'s .ssh directory
  ansible.builtin.file:
    path: "{{ _jenkins_user_home }}/.ssh"
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_user }}"
    state: directory
    mode: "700"

- name: Create ssh config file for {{ jenkins_user }} 
  ansible.builtin.copy:
    dest: "{{ _jenkins_user_home }}/.ssh/config"
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_user }}"
    mode: "600"
    content: |
      #
      #
      # ANSIBLE MANAGED

      Host github.com
          HostName github.com
          User git
          IdentityFile ~/.ssh/id_rsa_github

- name: Add the private SSH key that can read/write from GitHub repos
  ansible.builtin.copy:
    dest: "{{ _jenkins_user_home }}/.ssh/id_rsa_github"
    src: "{{ github_key_controller_path }}"
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_user }}"
    mode: "600"

- name: Write the github.com host key to known_hosts
  ansible.builtin.shell: ssh-keyscan -H github.com >> ~/.ssh/known_hosts
  become: yes
  become_user: "{{ jenkins_user }}"
  changed_when: false
    
- name: Create the gps configuration file
  ansible.builtin.template:
    src: gps.json.j2
    dest: "{{ gps_config_file_path }}"
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_user }}"
    mode: "600"
  become: yes

- name: Register the {{ _jenkins_pyenv_root_path }} file inode
  ansible.builtin.stat:
    path: "{{ _jenkins_pyenv_root_path }}"
  register: jenkins_pyenv_root_inode

# MONITOR(cavcrosby): I anticipate that eventually I will no longer need to use
# my forked version of the pyenv-installer repo. This depends ultimately on the
# outcome of a particular pull request. Once a outcome is determined, this section
# should be updated.
# https://github.com/pyenv/pyenv-installer/pull/126
#
# - name: Grab the pyenv installer
#   ansible.builtin.get_url:
#     url: https://pyenv.run
#     dest: "{{ _pyenv_installer_path }}"
#     mode: "755"
#   when: not jenkins_pyenv_root_inode.stat.exists

- name: Checkout my pyenv-installer forked repo
  block:
    - name: Checkout the {{ repo_name }} repo
      ansible.builtin.git:
        dest: "{{ repo_dst }}"
        repo: "{{ repo_url }}"
        force: yes
        version: pyenv-install-tag

    - name: Copy the pyenv-installer to its intended location
      ansible.builtin.copy:
        dest: "{{ _pyenv_installer_path }}"
        src: "{{ repo_dst }}/bin/pyenv-installer"
        remote_src: yes
        mode: "755"

  vars:
    - repo_name: pyenv-installer
    - repo_url: https://github.com/cavcrosby/pyenv-installer
    - repo_dst: "{{ _jenkins_user_home }}/{{ repo_name }}"

- name: Get the running pyenv version
  ansible.builtin.shell:
    executable: /bin/bash
    cmd: set -o pipefail && . {{ _roots_home }}/.bashrc && pyenv --version | awk '{print "v"$2}'
  become: yes
  register: running_pyenv_version
  failed_when: false
  changed_when: false

- name: Remove pyenv from the system
  ansible.builtin.file:
    state: absent
    path: "{{ _jenkins_pyenv_root_path }}"
  when: running_pyenv_version.stdout != pyenv_version

- name: Run the pyenv installer
  ansible.builtin.command: "{{ _pyenv_installer_path }}"
  environment:
    PYENV_ROOT: "{{ _jenkins_pyenv_root_path }}"
    PYENV_GIT_TAG: "{{ pyenv_version }}"
  when: not jenkins_pyenv_root_inode.stat.exists
        or running_pyenv_version.stdout != pyenv_version

- name: Install a Python interpreter to be managed by pyenv
  ansible.builtin.shell: |
    . {{ _roots_home }}/.bashrc && pyenv install {{ default_pyenv_python }}
  when: not jenkins_pyenv_root_inode.stat.exists

- name: Give ownership of {{ _jenkins_pyenv_root_path }} to {{ jenkins_user }}
  ansible.builtin.file:
    path: "{{ _jenkins_pyenv_root_path }}"
    recurse: yes
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_user }}"
    state: directory

- name: Add jenkins user to sudoers
  ansible.builtin.copy:
    dest: /etc/sudoers.d/ansible-altaria
    content: |
      # ANSIBLE MANAGED
      {{ jenkins_user }}   ALL=(ALL:ALL) ALL
    mode: "440"
  become: yes

- name: Create jenkins-agent {{ jenkins_main_node_workingdir }} directory
  ansible.builtin.file:
    path: /var/lib/jenkins-agent/{{ jenkins_main_node_workingdir }}
    recurse: yes
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_user }}"
    state: directory
    mode: "755"
  become: yes
  changed_when: false

- name: Checkout the jenkins-infrastructure repo, and configure it
  block:
    - name: Checkout the {{ repo_name }} repo
      ansible.builtin.git:
        dest: "{{ repo_dst }}"
        repo: "{{ repo_url }}"
        force: yes
        version: "{{ jenkins_infrastructure_repo_tag }}"
      register: checkout_repo_check

    - name: Give ownership of {{ repo_name }} to {{ jenkins_user }}
      ansible.builtin.file:
        path: "{{ repo_dst }}"
        recurse: yes
        owner: "{{ jenkins_user }}"
        group: "{{ jenkins_user }}"
        state: directory
      changed_when: false

    # Would have made this a handler for when the repo updates but unfortunately you
    # cannot pass in parameters to handlers.
    - name: Remove {{ repo_name }}'s project configuration file
      ansible.builtin.file:
        path: "{{ repo_dst }}/{{ project_config_file }}"
        state: absent
      when: checkout_repo_check.before != checkout_repo_check.after

    - name: Make {{ repo_name }}'s project configuration file
      ansible.builtin.command:
        chdir: "{{ repo_dst }}"
        cmd: make {{ project_config_file }}
      register: make_all_targets_check
      changed_when: make_all_targets_check.rc != 0

    - name: Register the current {{ repo_name }}'s project configurations file inode
      ansible.builtin.stat:
        path: "{{ repo_dst }}/{{ project_config_file }}"
      register: current_project_config_inode

    - name: Append {{ repo_name }}'s project configurations
      ansible.builtin.import_role:
        name: cavcrosby.general.common
        tasks_from: managed_blockinfile
      vars:
        path: "{{ repo_dst }}/{{ project_config_file }}"
        block_identifier: "{{ repo_name }}'s project configurations"
        block_text: |
          export JENKINS_MAIN_NODE_URL="http://{{ jenkins_main_node_ipv4_addr }}:{{ jenkins_main_node_port }}"
          export JENKINS_AGENT_NAME="{{ ansible_lxd_host }}"
          export JENKINS_USERNAME="{{ jenkins_main_node_admin_id }}"
          export JENKINS_PASSWORD="{{ jenkins_main_node_admin_password }}"
          export JENKINS_WORKINGDIR="/var/lib/jenkins-agent/{{ jenkins_main_node_workingdir }}"

    - name: Register the {{ repo_name }}'s project configurations file inode
      ansible.builtin.stat:
        path: "{{ repo_dst }}/{{ project_config_file }}"
      register: project_config_inode

    - name: Run {{ repo_name }}'s 'make' clean
      ansible.builtin.command:
        chdir: "{{ repo_dst }}"
        cmd: make clean
      when: current_project_config_inode.stat.checksum != project_config_inode.stat.checksum

    - name: Make all {{ repo_name }}'s 'make' targets
      ansible.builtin.command:
        chdir: "{{ repo_dst }}"
        cmd: make all
      register: make_all_targets_check
      changed_when: make_all_targets_check.rc != 0

    - name: Make {{ connect_jenkins_agent_script_path }} executable
      ansible.builtin.file:
        path: "{{ connect_jenkins_agent_script_path }}"
        mode: "755"
        state: file

    - name: Run {{ connect_jenkins_agent_script_path }}
      ansible.builtin.command:
        chdir: "{{ repo_dst }}/scripts"
        cmd: "{{ connect_jenkins_agent_script_path }}"
      become: yes
      become_user: "{{ jenkins_user }}"
      register: connect_jenkins_agent_check
      changed_when: connect_jenkins_agent_check.rc != 0

  vars:
    - repo_name: jenkins-infrastructure
    - repo_url: https://github.com/cavcrosby/jenkins-infrastructure
    - repo_dst: "{{ _jenkins_user_home }}/{{ repo_name }}"
    - project_config_file: .conf
    - connect_jenkins_agent_script_path: "{{ repo_dst }}/scripts/connect_jenkins_agent"
