---
- name: Create lxc-source's data directory
  ansible.builtin.file:
    path: "{{ _lxd_data_dir }}"
    state: directory
    mode: "700"
  become: yes

- name: Create GOPATH's bin directory
  ansible.builtin.file:
    path: "{{ global_go_path }}/bin"
    state: directory
    mode: "775"
  become: yes

- name: Append PATH with GOPATH/bin for {{ ansible_user_id }}
  ansible.builtin.import_role:
    name: common
    tasks_from: lbyl_lineinfile
  vars:
    path: "{{ ansible_env['HOME'] }}/.bashrc"
    # TODO(cavcrosby): '# ANSIBLE MANAGED' header should also have a check to see
    # if it exists first before adding it (possibly again).
    regexp: '^export PATH="(.+:|)?{{ global_go_path }}/bin(:.+|)"'
    line: "\n# ANSIBLE MANAGED\nexport PATH=\"${PATH}:{{ global_go_path }}/bin\""
    line_identifier: "PATH appended with GOPATH/bin"

# This list is specific to Debian 11 at the moment. Can be expanded to a vars
# directory to install dependencies based on the distro.
- name: Install the LXD dependencies
  ansible.builtin.apt:
    pkg:
    - acl
    - attr
    - autoconf
    - dnsmasq-base
    - git
    - golang
    - libacl1-dev
    - libcap-dev
    - liblxc1
    # liblxc-dev would be lxc-dev in Debian repos
    - lxc-dev
    - libsqlite3-dev
    - libtool
    - libudev-dev
    - liblz4-dev
    - libuv1-dev
    - make
    - pkg-config
    - rsync
    - squashfs-tools
    - tar
    - tcl
    - xz-utils
    - ebtables
    state: present
    update_cache: yes
  become: yes

- name: Set USE_LXC_BRIDGE to false
  ansible.builtin.import_role:
    name: common
    tasks_from: lbyl_lineinfile
  become: yes
  vars:
    path: /etc/default/lxc-net
    regexp: '^export USE_LXC_BRIDGE=\"true\"$'
    line: "export USE_LXC_BRIDGE=\"false\""
    line_identifier: "USE_LXC_BRIDGE set to false"

- name: Check if LXC bridge still exists
  ansible.builtin.stat:
    path: /sys/class/net/{{ _default_lxc_bridge }}
  become: yes
  register: default_lxc_bridge_check
  
- name: Remove default LXC bridge
  ansible.builtin.shell: |
    ip link set {{ _default_lxc_bridge }} down
    ip link delete {{ _default_lxc_bridge }} type bridge
  become: yes
  when: default_lxc_bridge_check.stat.exists

- name: Check if the LXD is installed
  ansible.builtin.shell: |
    find "{{ global_go_path }}/bin" -name 'lxd' -type f
  become: yes
  register: lxd_check
  changed_when: lxd_check.stdout == ""
  notify:
    - Grab a LXD release tarball, and extract the archive
    - Build the LXD libraries
    - Build the LXD

- name: Flush LXD installation handlers
  ansible.builtin.meta: flush_handlers

- name: Update secure path with {{ global_go_path }}
  ansible.builtin.copy:
    dest: "/etc/sudoers.d/ansible-lxd-source"
    content: |
      # ANSIBLE MANAGED
      Defaults  secure_path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:{{ global_go_path }}/bin
    mode: "440"
  become: yes

- name: Create wrapper for the LXD
  ansible.builtin.copy:
    dest: "{{ lxd_wrapper_path }}"
    mode: "755"
    content: |
      #!/bin/sh
      #
      # ANSIBLE MANAGED

      set -e
      
      # constants
      PROGRAM_NAME="$(basename "$0")"
      readonly PROGRAM_NAME
      readonly ROOT_UID=0
      readonly LD_LIBRARY_PATH="{{ _lxd_ld_library_path }}"
      export LD_LIBRARY_PATH

      if [ "$(id --user)" != "${ROOT_UID}" ]; then
          echo "${PROGRAM_NAME}: wrapper must be ran as root!" >&2
          exit 1
      fi

      {{ global_go_path }}/bin/lxd "$@"
  become: yes

- name: Create subuid && subgid files
  ansible.builtin.copy:
    dest: "{{ item }}"
    mode: "644"
    content: |
      # ANSIBLE MANAGED
      root:100000:65536
      ansible:100000:65536
  become: yes
  loop:
    - /etc/subuid
    - /etc/subgid

- name: Add {{ ansible_user_id }} to 'sudo' group
  ansible.builtin.user:
    append: yes
    groups: sudo
    name: "{{ ansible_user_id }}"
  become: yes

# MONITOR(cavcrosby): ideally this should only run when the ansible user is added
# to the group that is allowed to interact with the LXD. That said, running this
# meta module inside of handler appears to not be possible at the moment? A few
# related GitHub issues are closed and are made part of ansible-core 2.11 or
# higher that "should" resolve this but I am not having such luck. For reference:
# https://github.com/ansible/ansible/issues/66414
# https://github.com/ansible/ansible/issues/50306
# https://docs.rackspace.com/blog/speeding-up-ssh-session-creation/
#
# When part of a handler as is, I get an error stating that the 'Shared connection to <client machine> closed'.
# When adding async/poll (async: 1, poll: 0), while the task now does not fail,
# the underlying connection does not seem to change (e.g. foo user is still not
# part of the group bar). This will need to be watched incase things change.
- name: Reset ssh connection
  ansible.builtin.meta: reset_connection
  changed_when: false

- name: Create a LXD service file
  ansible.builtin.copy:
    dest: /etc/systemd/system/lxd.service
    mode: "644"
    content: |
      [Unit]
      Description=Linux Container Daemon

      [Service]
      Type=exec
      ExecStart={{ lxd_wrapper_path }} --group sudo

      [Install]
      WantedBy=multi-user.target
  become: yes

- name: Enable the LXD service
  ansible.builtin.systemd:
    name: lxd
    enabled: yes
    state: started
    daemon_reload: yes
  become: yes

# MONITOR(cavcrosby): it was found that the LXD unix socket file would sometimes
# not exist by the time certain tasks were ran, causing them to fail/behave
# inappropriately. Time will tell if this task fixes the issue.
- name: Wait until the LXD socket is present before continuing
  wait_for:
    path: /var/lib/lxd/unix.socket
    timeout: 10

- name: Create the LXD preseed
  ansible.builtin.copy:
    dest: "{{ _lxd_remote_preseed_path }}"
    mode: "644"
    content: "{{ lxd_preseed }}"
  become: yes

- name: Get the LXD's preseed checksum
  ansible.builtin.stat:
    path: "{{ _lxd_remote_preseed_path }}"
  become: yes
  register: lxd_preseed_checksum

# For reference on the shell command (it was either this, truncate, or dd):
# https://unix.stackexchange.com/questions/254644/how-do-i-remove-the-newline-from-the-last-line-in-a-file-in-order-to-add-text-to
# This was done as it doesn't seem possible to interject a final newline in the
# preseed variable.
- name: Create the running LXD's preseed
  ansible.builtin.shell:
    lxd init --dump | perl -pi -e 'chomp if eof' > "{{ _running_lxd_remote_preseed_path }}"
  become: yes
  register: running_lxd_preseed_checksum
  changed_when: running_lxd_preseed_checksum.rc != 0

- name: Get the running LXD's preseed checksum
  ansible.builtin.stat:
    path: "{{ _running_lxd_remote_preseed_path }}"
  become: yes
  register: running_lxd_preseed_checksum

# LXD can be initialize 'n' number of times, meaning there is currently no
# absolute way to determine if LXD has been initialize. For reference:
# https://discuss.linuxcontainers.org/t/how-to-check-if-lxd-init-auto-already-ran/1635
- name: Initialize the LXD
  ansible.builtin.shell: lxd init --preseed < "{{ _lxd_remote_preseed_path }}"
  become: yes
  changed_when: lxd_preseed_checksum.stat.checksum != running_lxd_preseed_checksum.stat.checksum

- name: Set the trust password for the LXD
  ansible.builtin.shell: lxc config set core.trust_password '{{ lxd_trust_password }}'
  become: yes
  register: set_trust_password_check
  changed_when: set_trust_password_check.rc != 0

- name: Set LXD remote on this controller node
  delegate_to: 127.0.0.1
  ansible.builtin.shell: lxc remote add --accept-certificate --password={{ lxd_trust_password }} {{ ansible_default_ipv4.address }}
  # It was observed that while ansible will say that each server was added (e.g.
  # each command returns a exit status of 0, in parallel). Turns out that
  # occasionally only one (out of N) remote would be added. I speculate this
  # is because ${HOME}/.config/lxc/config.yml gets blocked to be written by one
  # of the processes adding a remote. Thus this task should be ran sequentially.
  throttle: 1
  register: lxc_remote_add_check
  failed_when: 
    - lxc_remote_add_check.rc != 0
    # 'Error: Remote x.x.x.x exists as <https://x.x.x.x:8443>'
    - "'exists' not in lxc_remote_add_check.stderr"
  changed_when: lxc_remote_add_check.rc == 0
