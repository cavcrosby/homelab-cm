---
- name: Setup ansible user's Python virtual environment (virtualenv)
  hosts: ctrservers

  pre_tasks:
    - name: Update apt's package index
      ansible.builtin.apt:
        update_cache: yes
      become: yes

  tasks:
    - name: Install other Python packages
      ansible.builtin.apt:
        name:
          - python3-venv
        state: present
      become: yes

    - name: Create a Python virtualenvs directory
      ansible.builtin.file:
        path: "{{ ansible_python_virtualenvs_path }}"
        state: directory
        mode: "755"

    - name: Create the {{ ansible_python_virtualenv }} Python virtualenv
      ansible.builtin.pip:
        # requests might not actually be used but the module requires a package to
        # install for initial virtualenv setup.
        name: requests
        virtualenv: "{{ ansible_python_virtualenvs_path }}/{{ ansible_python_virtualenv }}"
        virtualenv_command: /usr/bin/python3 -m venv "{{ ansible_python_virtualenvs_path }}/{{ ansible_python_virtualenv }}"

    - name: Add sourcing the {{ ansible_python_virtualenv }} Python virtualenv
      ansible.builtin.import_role:
        name: common
        tasks_from: managed_lineinfile
      vars:
        path: "{{ ansible_env['HOME'] }}/.bashrc"
        regexp: '^source "{{ ansible_python_virtualenvs_path }}/{{ ansible_python_virtualenv }}/bin/activate"'
        line: "source \"{{ ansible_python_virtualenvs_path }}/{{ ansible_python_virtualenv }}/bin/activate\""
        line_identifier: "sourcing the {{ ansible_python_virtualenv }} Python virtualenv"

- name: Install LXD
  hosts: ctrservers
  vars_files:
    - vars/ansible-secrets.yaml

  roles:
    - lxd_source

- name: Install Docker
  hosts: ctrservers

  pre_tasks:
    - name: Update apt's package index
      ansible.builtin.apt:
        update_cache: yes
      become: yes

  tasks:
    - name: Create {{ ansible_user_id }}'s 'Downloads' directory
      ansible.builtin.file:
        path: "{{ ansible_env['HOME'] }}/Downloads"
        state: directory
        mode: "700"

    - name: Install Docker dependencies
      ansible.builtin.apt:
        name:
          - ca-certificates
          - curl
          - gnupg
          - curl
        state: present
      become: yes

    - name: Grab Docker's official GPG key
      ansible.builtin.get_url:
        url: https://download.docker.com/linux/{{ ansible_distribution | lower }}/gpg
        dest: "{{ docker_keyring_download_path }}"
      notify:
        - Remove Docker's installed GPG key
        - Install Docker's GPG key

    - name: Flush handlers
      ansible.builtin.meta: flush_handlers

    - name: Add Docker's stable apt repository (x86_64)
      ansible.builtin.apt_repository:
        repo: >
          deb [arch=amd64 signed-by={{ docker_keyring_install_path }}]
          https://download.docker.com/linux/{{ ansible_distribution | lower }} {{ ansible_distribution_release }} stable
        state: present
      become: yes
      when: ansible_architecture == "x86_64"

    - name: Install the Docker Engine
      ansible.builtin.apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present
      become: yes

  handlers:
    - name: Remove Docker's installed GPG key
      ansible.builtin.file:
        path: "{{ docker_keyring_install_path }}"
        state: absent
      become: yes

    # --batch option is needed for gpg due to odd "gpg: cannot open '/dev/tty'" error.
    # For reference:
    # https://github.com/pipech/erpnext-docker-debian/issues/26
    - name: Install Docker's GPG key
      ansible.builtin.shell: |
        gpg --batch --output {{ docker_keyring_install_path }} --dearmor {{ docker_keyring_download_path }}
      become: yes

- name: Setup systemd-networkd networking
  hosts: ctrservers

  tasks:
    - name: Setup systemd-networkd networking
      ansible.builtin.include_role:
        name: systemd_networkd
      vars:
        systemd_networkd_files:
          - filename: "{{ ansible_default_ipv4.interface }}.link"
            Match:
              MACAddress: "{{ ansible_default_ipv4.macaddress }}"
            Link:
              NamePolicy: keep

          - filename: "{{ ansible_default_ipv4.interface }}.network"
            Match:
              Name: "{{ ansible_default_ipv4.interface }}"
            Network:
              DHCP: "ipv4"

- name: Create LXD containers
  hosts: ctrservers
  # Added as add_host only runs on one host out of all the hosts in a play.
  # For reference: 
  # https://stackoverflow.com/questions/42106527/ansible-how-to-call-module-add-host-for-all-hosts-of-the-play
  serial: 1
  vars_files:
    - vars/lxd-containers.yaml

  tasks:
    - name: Create LXD containers
      community.general.lxd_container:
        name: "{{ item.name }}"
        state: stopped
        profiles: ["default"]
        ignore_volatile_options: false
        source:
          type: image
          mode: pull
          alias: "{{ item.image }}"
          protocol: simplestreams
          server: https://images.linuxcontainers.org
      register: lxd_container_check
      changed_when: lxd_container_check.old_state == "absent"
      loop: "{{ lxd_containers }}"

    - name: Register the LXD containers as inventory
      ansible.builtin.add_host:
        # The 'name' attribute makes Ansible happy, trying to combine
        # name/ansible_lxd_host into 'ansible_host' did not appear to work. For reference:
        # https://docs.ansible.com/ansible/latest/collections/community/general/lxd_connection.html
        #
        # Also inspired by:
        # https://www.reddit.com/r/ansible/comments/9b03l8/managing_lxd_containers_on_remote_machines/
        name: "{{ inventory_hostname }}:{{ item.name }}"
        lxd_container_type: "{{ item.type }}"
        ansible_lxd_remote: "{{ ansible_default_ipv4.address }}"
        ansible_lxd_host: "{{ item.name }}"
        ansible_connection: lxd
        groups: [lxd_containers]
      loop: "{{ lxd_containers }}"

- name: Perform LXD container instance configuration
  hosts: ctrservers
  vars_files:
    - vars/lxd-containers.yaml

  tasks:
    # Allows all configs to be applicable (e.g. not having to use only those that
    # are permitted as "Live Updates").
    - name: Shut off LXD containers
      community.general.lxd_container:
        name: "{{ item.name }}"
        state: stopped
        ignore_volatile_options: false
      loop: "{{ lxd_containers }}"

    - name: Configure LXD container instances
      community.general.lxd_container:
        name: "{{ item.name }}"
        state: stopped
        ignore_volatile_options: false
        config: "{{ item.instance_config }}"
      loop: "{{ lxd_containers }}"

    - name: Turn back on LXD containers
      community.general.lxd_container:
        name: "{{ item.name }}"
        state: started
        ignore_volatile_options: false
        wait_for_ipv4_addresses: true
      register: lxd_container_check
      changed_when: lxd_container_check.old_state == "absent"
      loop: "{{ lxd_containers }}"

- name: Check/install Python on the LXD containers
  hosts: lxd_containers
  # Ansible seems to fail at gathering facts from a container if the provided image
  # does not have Python installed.
  gather_facts: no

  tasks:
    - name: Check if python3 is installed in container
      ansible.builtin.raw: dpkg -s python3
      register: python_install_check
      failed_when: python_install_check.rc not in [0, 1]
      changed_when: false

    - name: Install python3 in container
      ansible.builtin.raw: apt-get install --assume-yes python3
      when: python_install_check.rc == 1

- name: Group the LXD containers by type
  hosts: lxd_containers
  tasks:
    - name: Group the LXD containers by type
      ansible.builtin.group_by:
        key: "lxd_{{ lxd_container_type }}_containers"
      changed_when: false

- name: Perform initial configuration on the LXD altaria containers
  hosts: lxd_altaria_containers

  roles:
    - altaria
